b'/* fs/fat/nfs.c\n *\n * This software is licensed under the terms of the GNU General Public\n * License version 2, as published by the Free Software Foundation, and\n * may be copied, distributed, and modified under those terms.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n */\n\n#include <linux/exportfs.h>\n#include "fat.h"\n\nstruct fat_fid {\n\tu32 i_gen;\n\tu32 i_pos_low;\n\tu16 i_pos_hi;\n\tu16 parent_i_pos_hi;\n\tu32 parent_i_pos_low;\n\tu32 parent_i_gen;\n};\n\n#define FAT_FID_SIZE_WITHOUT_PARENT 3\n#define FAT_FID_SIZE_WITH_PARENT (sizeof(struct fat_fid)/sizeof(u32))\n\n/**\n * Look up a directory inode given its starting cluster.\n */\nstatic struct inode *fat_dget(struct super_block *sb, int i_logstart)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct hlist_head *head;\n\tstruct msdos_inode_info *i;\n\tstruct inode *inode = NULL;\n\n\thead = sbi->dir_hashtable + fat_dir_hash(i_logstart);\n\tspin_lock(&sbi->dir_hash_lock);\n\thlist_for_each_entry(i, head, i_dir_hash) {\n\t\tBUG_ON(i->vfs_inode.i_sb != sb);\n\t\tif (i->i_logstart != i_logstart)\n\t\t\tcontinue;\n\t\tinode = igrab(&i->vfs_inode);\n\t\tif (inode)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&sbi->dir_hash_lock);\n\treturn inode;\n}\n\nstatic struct inode *fat_ilookup(struct super_block *sb, u64 ino, loff_t i_pos)\n{\n\tif (MSDOS_SB(sb)->options.nfs == FAT_NFS_NOSTALE_RO)\n\t\treturn fat_iget(sb, i_pos);\n\n\telse {\n\t\tif ((ino < MSDOS_ROOT_INO) || (ino == MSDOS_FSINFO_INO))\n\t\t\treturn NULL;\n\t\treturn ilookup(sb, ino);\n\t}\n}\n\nstatic struct inode *__fat_nfs_get_inode(struct super_block *sb,\n\t\t\t\t       u64 ino, u32 generation, loff_t i_pos)\n{\n\tstruct inode *inode = fat_ilookup(sb, ino, i_pos);\n\n\tif (inode && generation && (inode->i_generation != generation)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\tif (inode == NULL && MSDOS_SB(sb)->options.nfs == FAT_NFS_NOSTALE_RO) {\n\t\tstruct buffer_head *bh = NULL;\n\t\tstruct msdos_dir_entry *de ;\n\t\tsector_t blocknr;\n\t\tint offset;\n\t\tfat_get_blknr_offset(MSDOS_SB(sb), i_pos, &blocknr, &offset);\n\t\tbh = sb_bread(sb, blocknr);\n\t\tif (!bh) {\n\t\t\tfat_msg(sb, KERN_ERR,\n\t\t\t\t"unable to read block(%llu) for building NFS inode",\n\t\t\t\t(llu)blocknr);\n\t\t\treturn inode;\n\t\t}\n\t\tde = (struct msdos_dir_entry *)bh->b_data;\n\t\t/* If a file is deleted on server and client is not updated\n\t\t * yet, we must not build the inode upon a lookup call.\n\t\t */\n\t\tif (IS_FREE(de[offset].name))\n\t\t\tinode = NULL;\n\t\telse\n\t\t\tinode = fat_build_inode(sb, &de[offset], i_pos);\n\t\tbrelse(bh);\n\t}\n\n\treturn inode;\n}\n\nstatic struct inode *fat_nfs_get_inode(struct super_block *sb,\n\t\t\t\t       u64 ino, u32 generation)\n{\n\n\treturn __fat_nfs_get_inode(sb, ino, generation, 0);\n}\n\nstatic int\nfat_encode_fh_nostale(struct inode *inode, __u32 *fh, int *lenp,\n\t\t      struct inode *parent)\n{\n\tint len = *lenp;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tstruct fat_fid *fid = (struct fat_fid *) fh;\n\tloff_t i_pos;\n\tint type = FILEID_FAT_WITHOUT_PARENT;\n\n\tif (parent) {\n\t\tif (len < FAT_FID_SIZE_WITH_PARENT) {\n\t\t\t*lenp = FAT_FID_SIZE_WITH_PARENT;\n\t\t\treturn FILEID_INVALID;\n\t\t}\n\t} else {\n\t\tif (len < FAT_FID_SIZE_WITHOUT_PARENT) {\n\t\t\t*lenp = FAT_FID_SIZE_WITHOUT_PARENT;\n\t\t\treturn FILEID_INVALID;\n\t\t}\n\t}\n\n\ti_pos = fat_i_pos_read(sbi, inode);\n\t*lenp = FAT_FID_SIZE_WITHOUT_PARENT;\n\tfid->i_gen = inode->i_generation;\n\tfid->i_pos_low = i_pos & 0xFFFFFFFF;\n\tfid->i_pos_hi = (i_pos >> 32) & 0xFFFF;\n\tif (parent) {\n\t\ti_pos = fat_i_pos_read(sbi, parent);\n\t\tfid->parent_i_pos_hi = (i_pos >> 32) & 0xFFFF;\n\t\tfid->parent_i_pos_low = i_pos & 0xFFFFFFFF;\n\t\tfid->parent_i_gen = parent->i_generation;\n\t\ttype = FILEID_FAT_WITH_PARENT;\n\t\t*lenp = FAT_FID_SIZE_WITH_PARENT;\n\t}\n\n\treturn type;\n}\n\n/**\n * Map a NFS file handle to a corresponding dentry.\n * The dentry may or may not be connected to the filesystem root.\n */\nstatic struct dentry *fat_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\t\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    fat_nfs_get_inode);\n}\n\nstatic struct dentry *fat_fh_to_dentry_nostale(struct super_block *sb,\n\t\t\t\t\t       struct fid *fh, int fh_len,\n\t\t\t\t\t       int fh_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct fat_fid *fid = (struct fat_fid *)fh;\n\tloff_t i_pos;\n\n\tswitch (fh_type) {\n\tcase FILEID_FAT_WITHOUT_PARENT:\n\t\tif (fh_len < FAT_FID_SIZE_WITHOUT_PARENT)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase FILEID_FAT_WITH_PARENT:\n\t\tif (fh_len < FAT_FID_SIZE_WITH_PARENT)\n\t\t\treturn NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\ti_pos = fid->i_pos_hi;\n\ti_pos = (i_pos << 32) | (fid->i_pos_low);\n\tinode = __fat_nfs_get_inode(sb, 0, fid->i_gen, i_pos);\n\n\treturn d_obtain_alias(inode);\n}\n\n/*\n * Find the parent for a file specified by NFS handle.\n * This requires that the handle contain the i_ino of the parent.\n */\nstatic struct dentry *fat_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\t\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    fat_nfs_get_inode);\n}\n\nstatic struct dentry *fat_fh_to_parent_nostale(struct super_block *sb,\n\t\t\t\t\t       struct fid *fh, int fh_len,\n\t\t\t\t\t       int fh_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct fat_fid *fid = (struct fat_fid *)fh;\n\tloff_t i_pos;\n\n\tif (fh_len < FAT_FID_SIZE_WITH_PARENT)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_FAT_WITH_PARENT:\n\t\ti_pos = fid->parent_i_pos_hi;\n\t\ti_pos = (i_pos << 32) | (fid->parent_i_pos_low);\n\t\tinode = __fat_nfs_get_inode(sb, 0, fid->parent_i_gen, i_pos);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}\n\n/*\n * Rebuild the parent for a directory that is not connected\n *  to the filesystem root\n */\nstatic\nstruct inode *fat_rebuild_parent(struct super_block *sb, int parent_logstart)\n{\n\tint search_clus, clus_to_match;\n\tstruct msdos_dir_entry *de;\n\tstruct inode *parent = NULL;\n\tstruct inode *dummy_grand_parent = NULL;\n\tstruct fat_slot_info sinfo;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tsector_t blknr = fat_clus_to_blknr(sbi, parent_logstart);\n\tstruct buffer_head *parent_bh = sb_bread(sb, blknr);\n\tif (!parent_bh) {\n\t\tfat_msg(sb, KERN_ERR,\n\t\t\t"unable to read cluster of parent directory");\n\t\treturn NULL;\n\t}\n\n\tde = (struct msdos_dir_entry *) parent_bh->b_data;\n\tclus_to_match = fat_get_start(sbi, &de[0]);\n\tsearch_clus = fat_get_start(sbi, &de[1]);\n\n\tdummy_grand_parent = fat_dget(sb, search_clus);\n\tif (!dummy_grand_parent) {\n\t\tdummy_grand_parent = new_inode(sb);\n\t\tif (!dummy_grand_parent) {\n\t\t\tbrelse(parent_bh);\n\t\t\treturn parent;\n\t\t}\n\n\t\tdummy_grand_parent->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\t\tfat_fill_inode(dummy_grand_parent, &de[1]);\n\t\tMSDOS_I(dummy_grand_parent)->i_pos = -1;\n\t}\n\n\tif (!fat_scan_logstart(dummy_grand_parent, clus_to_match, &sinfo))\n\t\tparent = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\n\tbrelse(parent_bh);\n\tiput(dummy_grand_parent);\n\n\treturn parent;\n}\n\n/*\n * Find the parent for a directory that is not currently connected to\n * the filesystem root.\n *\n * On entry, the caller holds child_dir->d_inode->i_mutex.\n */\nstatic struct dentry *fat_get_parent(struct dentry *child_dir)\n{\n\tstruct super_block *sb = child_dir->d_sb;\n\tstruct buffer_head *bh = NULL;\n\tstruct msdos_dir_entry *de;\n\tstruct inode *parent_inode = NULL;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\n\tif (!fat_get_dotdot_entry(child_dir->d_inode, &bh, &de)) {\n\t\tint parent_logstart = fat_get_start(sbi, de);\n\t\tparent_inode = fat_dget(sb, parent_logstart);\n\t\tif (!parent_inode && sbi->options.nfs == FAT_NFS_NOSTALE_RO)\n\t\t\tparent_inode = fat_rebuild_parent(sb, parent_logstart);\n\t}\n\tbrelse(bh);\n\n\treturn d_obtain_alias(parent_inode);\n}\n\nconst struct export_operations fat_export_ops = {\n\t.fh_to_dentry   = fat_fh_to_dentry,\n\t.fh_to_parent   = fat_fh_to_parent,\n\t.get_parent     = fat_get_parent,\n};\n\nconst struct export_operations fat_export_ops_nostale = {\n\t.encode_fh      = fat_encode_fh_nostale,\n\t.fh_to_dentry   = fat_fh_to_dentry_nostale,\n\t.fh_to_parent   = fat_fh_to_parent_nostale,\n\t.get_parent     = fat_get_parent,\n};\n\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
